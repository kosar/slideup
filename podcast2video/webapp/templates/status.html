<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Processing Status - Podcast2Video</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>
<body>
    <div class="container mt-5">
        <div class="row">
            <div class="col-md-8 offset-md-2">
                <div class="card">
                    <div class="card-header bg-primary text-white">
                        <h2 class="text-center">Processing Status</h2>
                    </div>
                    <div class="card-body">
                        {% with messages = get_flashed_messages(with_categories=true) %}
                            {% if messages %}
                                {% for category, message in messages %}
                                    <div class="alert alert-{{ category if category != 'error' else 'danger' }}">
                                        {{ message }}
                                    </div>
                                {% endfor %}
                            {% endif %}
                        {% endwith %}
                        
                        <div class="text-center mb-4">
                            <h4 id="status-message">{{ status.message }}</h4>
                        </div>
                        
                        <div class="progress mb-4" style="height: 25px;">
                            <div id="progress-bar" class="progress-bar progress-bar-striped progress-bar-animated" 
                                role="progressbar" 
                                style="width: {{ status.progress }}%;" 
                                aria-valuenow="{{ status.progress }}" 
                                aria-valuemin="0" 
                                aria-valuemax="100">{{ status.progress }}%</div>
                        </div>
                        
                        <div id="status-details" class="mb-4">
                            <div class="alert alert-info">
                                <p><strong>Task ID:</strong> {{ task_id }}</p>
                                <p><strong>Status:</strong> <span id="status-text">{{ status.status }}</span></p>
                                {% if status.start_time %}
                                <p><strong>Started:</strong> {{ status.start_time | datetime }}</p>
                                {% endif %}
                            </div>
                        </div>

                        <div id="logs-section" class="mb-4">
                            <h5>Processing Logs</h5>
                            <div class="border rounded p-3" style="max-height: 200px; overflow-y: auto;">
                                <pre id="logs-content" class="mb-0">{{ status.logs | join('\n') }}</pre>
                            </div>
                        </div>
                        
                        <div id="cancel-section" class="text-center mb-4 {% if status.status not in ['starting', 'processing'] %}d-none{% endif %}">
                            <button id="cancel-button" class="btn btn-danger">
                                <span class="spinner-border spinner-border-sm d-none" id="cancel-spinner" role="status" aria-hidden="true"></span>
                                Cancel Processing
                            </button>
                        </div>
                        
                        <div id="download-section" class="text-center mb-4 {% if status.status != 'completed' %}d-none{% endif %}">
                            <div class="alert alert-success">
                                <h5>Processing Complete!</h5>
                                <p>Your video is ready for download.</p>
                                <a href="{{ url_for('download', task_id=task_id) }}" class="btn btn-success btn-lg" id="download-button">
                                    Download Video
                                </a>
                            </div>
                        </div>
                        
                        <div id="cancelled-section" class="text-center mb-4 {% if status.status != 'cancelled' %}d-none{% endif %}">
                            <div class="alert alert-info">
                                <h5>Processing Cancelled</h5>
                                <p>The video processing was successfully cancelled.</p>
                                <a href="{{ url_for('index') }}" class="btn btn-primary">
                                    Upload New File
                                </a>
                            </div>
                        </div>
                        
                        <div id="error-section" class="text-center mb-4 {% if status.status != 'failed' %}d-none{% endif %}">
                            <div class="alert alert-danger">
                                <h5>Processing Failed</h5>
                                <p id="error-message">{{ status.message }}</p>
                                <a href="{{ url_for('index') }}" class="btn btn-primary">
                                    Try Again
                                </a>
                            </div>
                        </div>
                        
                        <div class="d-grid gap-2">
                            <a href="{{ url_for('index') }}" class="btn btn-outline-secondary">Back to Upload</a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Polling for status updates
        const taskId = "{{ task_id }}";
        const statusUrl = "/api/status/" + taskId;
        let pollInterval;
        let lastLogCount = {{ status.logs | length }};
        let startTime = new Date().getTime();
        
        function updateStatus() {
            fetch(statusUrl)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Status update:', data);
                    
                    // Update progress bar
                    const progressBar = document.getElementById('progress-bar');
                    progressBar.style.width = data.progress + '%';
                    progressBar.setAttribute('aria-valuenow', data.progress);
                    progressBar.textContent = data.progress + '%';
                    
                    // Update status message
                    document.getElementById('status-message').textContent = data.message;
                    document.getElementById('status-text').textContent = data.status;
                    
                    // Update logs if new entries exist
                    if (data.logs && data.logs.length > lastLogCount) {
                        const logsContent = document.getElementById('logs-content');
                        logsContent.textContent = data.logs.join('\n');
                        logsContent.scrollTop = logsContent.scrollHeight;
                        lastLogCount = data.logs.length;
                    }
                    
                    // Show/hide sections based on status
                    if (data.status === 'completed') {
                        document.getElementById('download-section').classList.remove('d-none');
                        document.getElementById('cancel-section').classList.add('d-none');
                        document.getElementById('download-button').href = `/download/${taskId}`;
                        clearInterval(pollInterval);
                    } else if (data.status === 'failed') {
                        document.getElementById('error-section').classList.remove('d-none');
                        document.getElementById('cancel-section').classList.add('d-none');
                        document.getElementById('error-message').textContent = data.message;
                        clearInterval(pollInterval);
                    } else if (data.status === 'cancelled') {
                        document.getElementById('cancelled-section').classList.remove('d-none');
                        document.getElementById('cancel-section').classList.add('d-none');
                        clearInterval(pollInterval);
                    } else if (data.status === 'cancelling') {
                        document.getElementById('cancel-button').disabled = true;
                        document.getElementById('cancel-spinner').classList.remove('d-none');
                        document.getElementById('cancel-button').textContent = ' Cancelling...';
                    } else if (data.status !== 'starting' && data.status !== 'processing') {
                        document.getElementById('cancel-section').classList.add('d-none');
                    }
                })
                .catch(error => {
                    console.error('Error fetching status:', error);
                    // Don't stop polling on network errors
                });
        }
        
        // Cancel button handler
        document.getElementById('cancel-button').addEventListener('click', function() {
            if (!confirm('Are you sure you want to cancel this processing task?')) {
                return;
            }
            
            // Disable button and show spinner
            this.disabled = true;
            document.getElementById('cancel-spinner').classList.remove('d-none');
            this.textContent = ' Cancelling...';
            
            // Send cancellation request
            fetch(`/api/cancel/${taskId}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            })
            .then(response => {
                if (!response.ok && response.status !== 200) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log('Cancellation response:', data);
                
                // Update status based on response
                if (data.status === 'cancelled' || data.status === 'cancelling') {
                    document.getElementById('status-message').textContent = data.message || 'Processing cancelled by user';
                    document.getElementById('status-text').textContent = 'cancelled';
                    
                    // Show cancelled section instead of error section
                    document.getElementById('cancelled-section').classList.remove('d-none');
                    document.getElementById('error-section').classList.add('d-none');
                    
                    document.getElementById('cancel-section').classList.add('d-none');
                    
                    // Stop polling
                    clearInterval(pollInterval);
                } else if (data.status === 'error') {
                    // Reset button if cancellation failed
                    document.getElementById('cancel-button').disabled = false;
                    document.getElementById('cancel-spinner').classList.add('d-none');
                    document.getElementById('cancel-button').textContent = 'Cancel Processing';
                    
                    // Show error message
                    alert(`Failed to cancel: ${data.message}`);
                } else {
                    // Task is in a state that can't be cancelled (already completed, etc.)
                    document.getElementById('cancel-section').classList.add('d-none');
                    
                    // Show appropriate message
                    alert(`Task is already ${data.status}: ${data.message}`);
                }
            })
            .catch(error => {
                console.error('Error cancelling task:', error);
                
                // Reset button
                document.getElementById('cancel-button').disabled = false;
                document.getElementById('cancel-spinner').classList.add('d-none');
                document.getElementById('cancel-button').textContent = 'Cancel Processing';
                
                // Show error message
                alert('Error communicating with the server. Please try again.');
            });
        });
        
        // Start polling
        document.addEventListener('DOMContentLoaded', function() {
            // Initial check of status
            updateStatus();
            
            // Set up polling every 1 second
            pollInterval = setInterval(updateStatus, 1000);
            
            // Stop polling after 30 minutes (prevents runaway polling)
            setTimeout(() => {
                clearInterval(pollInterval);
                if (document.getElementById('status-text').textContent !== 'completed' && 
                    document.getElementById('status-text').textContent !== 'failed') {
                    document.getElementById('error-section').classList.remove('d-none');
                    document.getElementById('error-message').textContent = 'Processing timed out after 30 minutes.';
                }
            }, 30 * 60 * 1000);
        });
    </script>
</body>
</html> 